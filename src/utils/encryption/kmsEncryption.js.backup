// src/utils/encryption/kmsEncryption.js
import { KMSClient, EncryptCommand, DecryptCommand, GenerateDataKeyCommand } from '@aws-sdk/client-kms';
import CryptoJS from "crypto-js";

class KMSEncryptionSystem {
  constructor() {
    // KMS í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™”
    this.kmsClient = new KMSClient({ 
      region: process.env.AWS_REGION || 'ap-northeast-2',
      credentials: {
        accessKeyId: process.env.AWS_ACCESS_KEY_ID,
        secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY
      }
    });

    // í™˜ê²½ ì„¤ì •
    this.kmsKeyId = process.env.KMS_KEY_ID || 'alias/loco-user-data';
    this.enableKMS = process.env.ENABLE_KMS === 'true';
    this.fallbackKey = process.env.ENCRYPTION_SECRET || 'loco-fallback-key';
    
    // ë°ì´í„° í‚¤ ìºì‹œ (ì„±ëŠ¥ ìµœì í™”)
    this.dataKeyCache = new Map();
    this.cacheMaxSize = parseInt(process.env.KMS_CACHE_MAX_SIZE) || 100;
    this.cacheExpiry = parseInt(process.env.KMS_CACHE_EXPIRY) || 30 * 60 * 1000; // 30ë¶„
    
    // í†µê³„ ì¶”ì 
    this.stats = {
      totalEncryptions: 0,
      totalDecryptions: 0,
      cacheHits: 0,
      cacheMisses: 0,
      errors: 0
    };
    
    console.log(`ğŸ” KMS ì•”í˜¸í™” ì‹œìŠ¤í…œ ì´ˆê¸°í™”: ${this.enableKMS ? 'KMS í™œì„±í™”' : 'Fallback ëª¨ë“œ'}`);
    console.log(`ğŸ”‘ KMS Key ID: ${this.kmsKeyId}`);
  }

  // ğŸ”‘ ë°ì´í„° í‚¤ ìƒì„±/ìºì‹œ ê´€ë¦¬
  async getDataKey(keySpec = 'AES_256') {
    const cacheKey = `datakey_${keySpec}`;
    const cached = this.dataKeyCache.get(cacheKey);
    
    // ìºì‹œëœ í‚¤ê°€ ìœ íš¨í•œì§€ í™•ì¸
    if (cached && (Date.now() - cached.timestamp) < this.cacheExpiry) {
      this.stats.cacheHits++;
      return cached.key;
    }

    this.stats.cacheMisses++;

    try {
      const command = new GenerateDataKeyCommand({
        KeyId: this.kmsKeyId,
        KeySpec: keySpec
      });
      
      const response = await this.kmsClient.send(command);
      const dataKey = {
        plaintext: response.Plaintext,
        encrypted: response.CiphertextBlob,
        timestamp: Date.now()
      };

      // ìºì‹œ í¬ê¸° ê´€ë¦¬
      if (this.dataKeyCache.size >= this.cacheMaxSize) {
        const oldestKey = Array.from(this.dataKeyCache.keys())[0];
        this.dataKeyCache.delete(oldestKey);
      }

      this.dataKeyCache.set(cacheKey, { key: dataKey, timestamp: Date.now() });
      return dataKey;
    } catch (error) {
      this.stats.errors++;
      console.error('âŒ KMS ë°ì´í„° í‚¤ ìƒì„± ì‹¤íŒ¨:', error.message);
      
      // ê°œë°œí™˜ê²½ì—ì„œëŠ” fallback, ìš´ì˜í™˜ê²½ì—ì„œëŠ” ì—ëŸ¬
      if (process.env.NODE_ENV === 'development' && process.env.DEV_USE_FALLBACK === 'true') {
        console.log('ğŸ”„ ê°œë°œí™˜ê²½: Fallback ëª¨ë“œë¡œ ì „í™˜');
        return null; // fallback ì‚¬ìš© ì‹ í˜¸
      }
      
      throw error;
    }
  }

  // ğŸ” ê°œì¸ì •ë³´ ì•”í˜¸í™” (KMS + AES í•˜ì´ë¸Œë¦¬ë“œ)
  async encryptPersonalInfo(data, userContext = {}) {
    if (!data) return null;

    this.stats.totalEncryptions++;

    try {
      if (!this.enableKMS) {
        return this.fallbackEncrypt(data);
      }

      // KMSë¡œ ë°ì´í„° í‚¤ ìƒì„±
      const dataKey = await this.getDataKey();
      
      // ë°ì´í„° í‚¤ ìƒì„± ì‹¤íŒ¨ ì‹œ fallback
      if (!dataKey) {
        return this.fallbackEncrypt(data);
      }
      
      // ì‚¬ìš©ì ì»¨í…ìŠ¤íŠ¸ ì •ë³´ë¡œ ì¶”ê°€ ë³´ì•ˆ
      const context = {
        userId: userContext.userId || 'anonymous',
        dataType: userContext.dataType || 'personal',
        timestamp: Date.now().toString()
      };

      // AES-256ìœ¼ë¡œ ì‹¤ì œ ë°ì´í„° ì•”í˜¸í™”
      const encrypted = CryptoJS.AES.encrypt(
        JSON.stringify({ data, context }), 
        Buffer.from(dataKey.plaintext).toString('base64')
      ).toString();

      return {
        encrypted,
        dataKeyEncrypted: Buffer.from(dataKey.encrypted).toString('base64'),
        algorithm: 'KMS-AES256',
        context,
        version: '1.0'
      };

    } catch (error) {
      this.stats.errors++;
      console.error('âŒ KMS ê°œì¸ì •ë³´ ì•”í˜¸í™” ì‹¤íŒ¨:', error.message);
      
      // í´ë°±: ê¸°ì¡´ ë°©ì‹ ì‚¬ìš©
      return this.fallbackEncrypt(data);
    }
  }

  // ğŸ”“ ê°œì¸ì •ë³´ ë³µí˜¸í™”
  async decryptPersonalInfo(encryptedData, userContext = {}) {
    if (!encryptedData) return null;

    this.stats.totalDecryptions++;

    try {
      // KMS ì•”í˜¸í™”ëœ ë°ì´í„°ì¸ì§€ í™•ì¸
      if (typeof encryptedData === 'object' && encryptedData.algorithm === 'KMS-AES256') {
        return await this.kmsDecrypt(encryptedData, userContext);
      }
      
      // ë ˆê±°ì‹œ ë°ì´í„° ì²˜ë¦¬
      return this.fallbackDecrypt(encryptedData);

    } catch (error) {
      this.stats.errors++;
      console.error('âŒ ê°œì¸ì •ë³´ ë³µí˜¸í™” ì‹¤íŒ¨:', error.message);
      return this.fallbackDecrypt(encryptedData);
    }
  }

  // KMS ë³µí˜¸í™”
  async kmsDecrypt(encryptedData, userContext = {}) {
    try {
      // ë°ì´í„° í‚¤ ë³µí˜¸í™”
      const decryptCommand = new DecryptCommand({
        CiphertextBlob: Buffer.from(encryptedData.dataKeyEncrypted, 'base64')
      });
      
      const keyResponse = await this.kmsClient.send(decryptCommand);
      const plaintextKey = Buffer.from(keyResponse.Plaintext).toString('base64');

      // ì‹¤ì œ ë°ì´í„° ë³µí˜¸í™”
      const bytes = CryptoJS.AES.decrypt(encryptedData.encrypted, plaintextKey);
      const decryptedStr = bytes.toString(CryptoJS.enc.Utf8);
      const { data, context } = JSON.parse(decryptedStr);

      // ì»¨í…ìŠ¤íŠ¸ ê²€ì¦ (ì„ íƒì )
      if (userContext.strictValidation) {
        this.validateContext(context, userContext);
      }

      return data;
    } catch (error) {
      console.error('âŒ KMS ë³µí˜¸í™” ì‹¤íŒ¨:', error.message);
      throw error;
    }
  }

  // ğŸ”’ ì†Œì…œ ë¡œê·¸ì¸ ì •ë³´ ì§ì ‘ KMS ì•”í˜¸í™” (ìµœê³  ë³´ì•ˆ)
  async encryptSocialInfo(socialData, provider, userId) {
    try {
      if (!this.enableKMS) {
        return this.fallbackEncrypt(JSON.stringify(socialData));
      }

      const context = {
        userId: userId || 'anonymous',
        provider,
        dataType: 'social_login',
        timestamp: Date.now().toString()
      };

      // ì§ì ‘ KMS ì•”í˜¸í™” (ë” ë†’ì€ ë³´ì•ˆ ë ˆë²¨)
      const encryptCommand = new EncryptCommand({
        KeyId: this.kmsKeyId,
        Plaintext: Buffer.from(JSON.stringify({ socialData, context })),
        EncryptionContext: context
      });

      const response = await this.kmsClient.send(encryptCommand);
      
      return {
        encrypted: Buffer.from(response.CiphertextBlob).toString('base64'),
        algorithm: 'KMS-DIRECT',
        context,
        version: '1.0'
      };

    } catch (error) {
      console.error('âŒ ì†Œì…œì •ë³´ KMS ì•”í˜¸í™” ì‹¤íŒ¨:', error.message);
      return this.fallbackEncrypt(JSON.stringify(socialData));
    }
  }

  // ğŸ”“ ì†Œì…œ ë¡œê·¸ì¸ ì •ë³´ ë³µí˜¸í™”
  async decryptSocialInfo(encryptedData) {
    if (!encryptedData) return null;

    try {
      if (typeof encryptedData === 'object' && encryptedData.algorithm === 'KMS-DIRECT') {
        const decryptCommand = new DecryptCommand({
          CiphertextBlob: Buffer.from(encryptedData.encrypted, 'base64'),
          EncryptionContext: encryptedData.context
        });

        const response = await this.kmsClient.send(decryptCommand);
        const decryptedStr = Buffer.from(response.Plaintext).toString('utf8');
        const { socialData } = JSON.parse(decryptedStr);

        return socialData;
      }

      // ë ˆê±°ì‹œ ë°ì´í„°
      return JSON.parse(this.fallbackDecrypt(encryptedData));

    } catch (error) {
      console.error('âŒ ì†Œì…œì •ë³´ ë³µí˜¸í™” ì‹¤íŒ¨:', error.message);
      return JSON.parse(this.fallbackDecrypt(encryptedData));
    }
  }

  // ğŸ”„ ë°°ì¹˜ ì•”í˜¸í™” (ë‹¤ìˆ˜ ì‚¬ìš©ì ë°ì´í„° ì²˜ë¦¬)
  async encryptUserBatch(users, batchSize = 10) {
    const results = [];
    
    for (let i = 0; i < users.length; i += batchSize) {
      const batch = users.slice(i, i + batchSize);
      const batchPromises = batch.map(async (user) => {
        try {
          const encrypted = await this.encryptUserData(user);
          return { success: true, userId: user._id, data: encrypted };
        } catch (error) {
          return { success: false, userId: user._id, error: error.message };
        }
      });

      const batchResults = await Promise.allSettled(batchPromises);
      results.push(...batchResults.map(r => r.value || r.reason));
      
      // ë°°ì¹˜ ê°„ ì ì‹œ ëŒ€ê¸° (API ì œí•œ ë°©ì§€)
      if (i + batchSize < users.length) {
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    }

    return results;
  }

  // ğŸ“Š ì•”í˜¸í™” í†µê³„ ë° ëª¨ë‹ˆí„°ë§
  getEncryptionStats() {
    const cacheHitRate = this.stats.cacheHits + this.stats.cacheMisses > 0 
      ? (this.stats.cacheHits / (this.stats.cacheHits + this.stats.cacheMisses) * 100).toFixed(2)
      : 0;

    return {
      kmsEnabled: this.enableKMS,
      dataKeyCacheSize: this.dataKeyCache.size,
      cacheHitRate: `${cacheHitRate}%`,
      totalEncryptions: this.stats.totalEncryptions,
      totalDecryptions: this.stats.totalDecryptions,
      errors: this.stats.errors,
      lastActivity: new Date().toISOString()
    };
  }

  // ğŸ§¹ ìºì‹œ ì •ë¦¬
  clearExpiredCache() {
    const now = Date.now();
    for (const [key, value] of this.dataKeyCache.entries()) {
      if (now - value.timestamp > this.cacheExpiry) {
        this.dataKeyCache.delete(key);
      }
    }
  }

  // í´ë°± ì•”í˜¸í™” (ê¸°ì¡´ ë°©ì‹)
  fallbackEncrypt(data) {
    try {
      return CryptoJS.AES.encrypt(data.toString(), this.fallbackKey).toString();
    } catch (error) {
      console.error('âŒ í´ë°± ì•”í˜¸í™” ì‹¤íŒ¨:', error);
      return data; // ìµœí›„ í´ë°±
    }
  }

  // í´ë°± ë³µí˜¸í™” (ê¸°ì¡´ ë°©ì‹)
  fallbackDecrypt(encryptedData) {
    try {
      // ì´ë¯¸ í‰ë¬¸ì¸ ê²½ìš° ì²´í¬
      if (!encryptedData.toString().includes("U2FsdGVk")) {
        return encryptedData; // ì´ë¯¸ í‰ë¬¸
      }
      
      const bytes = CryptoJS.AES.decrypt(encryptedData, this.fallbackKey);
      return bytes.toString(CryptoJS.enc.Utf8) || encryptedData;
    } catch (error) {
      console.error('âŒ í´ë°± ë³µí˜¸í™” ì‹¤íŒ¨:', error);
      return encryptedData; // ìµœí›„ í´ë°±
    }
  }

  // ì»¨í…ìŠ¤íŠ¸ ê²€ì¦
  validateContext(storedContext, expectedContext) {
    if (expectedContext.userId && storedContext.userId !== expectedContext.userId) {
      throw new Error('ì‚¬ìš©ì ID ë¶ˆì¼ì¹˜');
    }
    
    if (expectedContext.dataType && storedContext.dataType !== expectedContext.dataType) {
      throw new Error('ë°ì´í„° íƒ€ì… ë¶ˆì¼ì¹˜');
    }
  }

  // ğŸ” ì‚¬ìš©ì ë°ì´í„° í†µí•© ì•”í˜¸í™”
  async encryptUserData(userData) {
    const encrypted = { ...userData };

    // ì•”í˜¸í™” í™œì„±í™” í™•ì¸
    if (!this.enableKMS && process.env.ENABLE_ENCRYPTION !== 'true') {
      return encrypted; // ì•”í˜¸í™” ë¹„í™œì„±í™” ì‹œ ì›ë³¸ ë°˜í™˜
    }

    // ê¸°ë³¸ ê°œì¸ì •ë³´ ì•”í˜¸í™” (KMS + í•´ì‹œ)
    if (userData.name) {
      encrypted.name = await this.encryptPersonalInfo(userData.name, {
        userId: userData._id?.toString(),
        dataType: 'name'
      });
      encrypted.name_hash = this.createSearchHash(userData.name);
    }

    if (userData.phone) {
      encrypted.phone = await this.encryptPersonalInfo(userData.phone, {
        userId: userData._id?.toString(),
        dataType: 'phone'
      });
      encrypted.phone_hash = this.createPhoneHash(userData.phone);
    }

    if (userData.birthdate) {
      encrypted.birthdate = await this.encryptPersonalInfo(userData.birthdate, {
        userId: userData._id?.toString(),
        dataType: 'birthdate'
      });
      encrypted.birthdate_hash = this.createSearchHash(userData.birthdate);
    }

    // ì†Œì…œ ì •ë³´ ì°¨ë“± ì²˜ë¦¬
    if (userData.social) {
      if (userData.social.kakao) {
        encrypted.social = encrypted.social || {};
        encrypted.social.kakao = await this.encryptSocialInfo(
          userData.social.kakao, 
          'kakao', 
          userData._id?.toString()
        );
      }

      if (userData.social.naver) {
        encrypted.social = encrypted.social || {};
        encrypted.social.naver = await this.encryptSocialInfo(
          userData.social.naver, 
          'naver', 
          userData._id?.toString()
        );
      }
    }

    return encrypted;
  }

  // ğŸ”“ ì‚¬ìš©ì ë°ì´í„° ì¼ê´„ ë³µí˜¸í™” (ê´€ë¦¬ììš© + ë‚˜ì´ ê³„ì‚°)
  async decryptUserData(encryptedUserData) {
    const decrypted = { ...encryptedUserData };

    // ê¸°ë³¸ ê°œì¸ì •ë³´ ë³µí˜¸í™”
    if (encryptedUserData.name) {
      decrypted.decrypted_name = await this.decryptPersonalInfo(encryptedUserData.name);
    }

    if (encryptedUserData.phone) {
      decrypted.decrypted_phone = await this.decryptPersonalInfo(encryptedUserData.phone);
    }

    if (encryptedUserData.birthdate) {
      decrypted.decrypted_birthdate = await this.decryptPersonalInfo(encryptedUserData.birthdate);
      
      // ğŸ¯ ë³µí˜¸í™”ëœ ìƒë…„ì›”ì¼ë¡œ ë‚˜ì´ ê³„ì‚°
      if (decrypted.decrypted_birthdate) {
        decrypted.calculated_age = this.calculateAge(decrypted.decrypted_birthdate);
        decrypted.age_group = this.getAgeGroup(decrypted.decrypted_birthdate);
        decrypted.is_minor = this.isMinor(decrypted.decrypted_birthdate);
      }
    }

    // ì†Œì…œ ì •ë³´ ë³µí˜¸í™”
    if (encryptedUserData.social) {
      if (encryptedUserData.social.kakao) {
        decrypted.social = decrypted.social || {};
        decrypted.social.kakao = await this.decryptSocialInfo(encryptedUserData.social.kakao);
      }

      if (encryptedUserData.social.naver) {
        decrypted.social = decrypted.social || {};
        decrypted.social.naver = await this.decryptSocialInfo(encryptedUserData.social.naver);
      }
    }

    return decrypted;
  }

  // ğŸ” ì†Œì…œ ë¡œê·¸ì¸ ì‚¬ìš©ì ê²€ìƒ‰ (KMS ì§€ì›)
  async findUserBySocialId(User, provider, providerId) {
    try {
      // providerId í•´ì‹œë¡œ ê²€ìƒ‰ (KMSëŠ” í•´ì‹œ ê²€ìƒ‰ë§Œ ì§€ì›)
      const providerIdHash = this.hashProviderId(providerId);
      const hashField = `social.${provider}.providerId_hash`;
      
      const user = await User.findOne({ [hashField]: providerIdHash });
      if (user) return user;
      
      // ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ í´ë°± (ë ˆê±°ì‹œ ë°ì´í„°)
      const legacyField = `social.${provider}.providerId`;
      return await User.findOne({ [legacyField]: providerId });
      
    } catch (error) {
      console.error('ì†Œì…œ ì‚¬ìš©ì ê²€ìƒ‰ ì‹¤íŒ¨:', error);
      // ìµœí›„ í´ë°±
      const legacyField = `social.${provider}.providerId`;
      return await User.findOne({ [legacyField]: providerId });
    }
  }

  // ê²€ìƒ‰ìš© í•´ì‹œ ìƒì„± (ì¼ë°˜)
  createSearchHash(data) {
    if (!data) return null;
    try {
      return CryptoJS.SHA256(data.toString()).toString();
    } catch (error) {
      console.error("í•´ì‹œ ìƒì„± ì‹¤íŒ¨:", error);
      return null;
    }
  }

  // providerId ì „ìš© í•´ì‹œ (í•´ì‹œë§Œ, ì•”í˜¸í™” ì—†ìŒ)
  hashProviderId(providerId) {
    if (!providerId) return null;
    try {
      return CryptoJS.SHA256(providerId.toString()).toString();
    } catch (error) {
      console.error("providerId í•´ì‹œ ì‹¤íŒ¨:", error);
      return providerId.toString(); // ì‹¤íŒ¨ ì‹œ ì›ë³¸ ë°˜í™˜
    }
  }

  // ì „í™”ë²ˆí˜¸ íŠ¹ìˆ˜ í•´ì‹œ (ë§ˆì§€ë§‰ 4ìë¦¬ ê¸°ë°˜)
  createPhoneHash(phoneNumber) {
    if (!phoneNumber) return null;
    try {
      const lastFour = phoneNumber.toString().slice(-4);
      return CryptoJS.SHA256(lastFour).toString();
    } catch (error) {
      console.error("ì „í™”ë²ˆí˜¸ í•´ì‹œ ì‹¤íŒ¨:", error);
      return null;
    }
  }

  // ğŸ¯ í•œêµ­ ë§Œ ë‚˜ì´ ì •í™• ê³„ì‚° (í•µì‹¬ ë©”ì„œë“œ)
  calculateAge(birthdate) {
    if (!birthdate) return null;
    
    try {
      // ë‹¤ì–‘í•œ ë‚ ì§œ í˜•ì‹ ì§€ì›
      let parsedDate;
      if (birthdate.includes('-')) {
        // YYYY-MM-DD ë˜ëŠ” YYYY-M-D í˜•ì‹
        parsedDate = new Date(birthdate + 'T00:00:00.000Z');
      } else if (birthdate.length === 8) {
        // YYYYMMDD í˜•ì‹
        const year = birthdate.substring(0, 4);
        const month = birthdate.substring(4, 6);
        const day = birthdate.substring(6, 8);
        parsedDate = new Date(`${year}-${month}-${day}T00:00:00.000Z`);
      } else {
        parsedDate = new Date(birthdate);
      }
      
      if (isNaN(parsedDate.getTime())) return null;
      
      const today = new Date();
      const birthYear = parsedDate.getUTCFullYear();
      const birthMonth = parsedDate.getUTCMonth();
      const birthDay = parsedDate.getUTCDate();
      
      const currentYear = today.getFullYear();
      const currentMonth = today.getMonth();
      const currentDay = today.getDate();
      
      // ê¸°ë³¸ ë‚˜ì´ ê³„ì‚°
      let age = currentYear - birthYear;
      
      // ìƒì¼ì´ ì§€ë‚˜ì§€ ì•Šì•˜ìœ¼ë©´ 1ì‚´ ë¹¼ê¸°
      if (currentMonth < birthMonth || 
          (currentMonth === birthMonth && currentDay < birthDay)) {
        age--;
      }
      
      return age >= 0 ? age : null;
    } catch (error) {
      console.error('ë§Œë‚˜ì´ ê³„ì‚° ì˜¤ë¥˜:', error);
      return null;
    }
  }

  // ğŸ¯ ë‚˜ì´ ë²”ìœ„ë³„ ë¶„ë¥˜ (í•œêµ­ ê¸°ì¤€ ë§¤ì¹­ìš©)
  getAgeGroup(birthdate) {
    const age = this.calculateAge(birthdate);
    if (age === null) return 'unknown';
    
    if (age < 13) return 'child';        // ì–´ë¦°ì´
    if (age < 20) return 'teen';         // ì²­ì†Œë…„ (ë§Œ 13-19ì„¸)
    if (age < 30) return 'twenties';     // 20ëŒ€
    if (age < 40) return 'thirties';     // 30ëŒ€
    if (age < 50) return 'forties';      // 40ëŒ€
    if (age < 60) return 'fifties';      // 50ëŒ€
    if (age < 70) return 'sixties';      // 60ëŒ€
    return 'senior';                     // 70ì„¸ ì´ìƒ
  }

  // ğŸ¯ ë¯¸ì„±ë…„ì ì—¬ë¶€ í™•ì¸ (í•œêµ­ ì²­ì†Œë…„ë³´í˜¸ë²• ì¤€ìˆ˜)
  isMinor(birthdate) {
    const age = this.calculateAge(birthdate);
    return age !== null && age < 19; // í•œêµ­ ê¸°ì¤€: ë§Œ 19ì„¸ ë¯¸ë§Œ
  }
}

export default new KMSEncryptionSystem();